The realloc() function resizes the block of memory pointed to by arr to the new size (in this case, space for 5 integers).
If the new size is smaller, realloc() will release the unused memory.
If the new size is larger, realloc() may allocate a new block of memory, copy the existing data to the new block, and free the old block.

If you allocate memory for 10 elements using malloc but only need 5 elements, 
you are essentially wasting half of the allocated memory.
The excess memory (that you allocated but don't use) will remain unused, which can lead to inefficient memory utilization, especially in large-scale programs.

Scenario:
Letâ€™s say you allocate memory for 10 integers but only use 5:


int* arr = (int*)malloc(10 * sizeof(int)); // Allocates space for 10 integers (e.g., 40 bytes if sizeof(int) is 4)

// But you only use 5 elements
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
arr[4] = 50;
Here, malloc(10 * sizeof(int)) allocates enough memory for 10 integers (e.g., 40 bytes), but since you only use 5 elements,
the remaining space (5 integers' worth, 20 bytes in this case) goes unused. While the operating system has reserved that memory for your program, you're not utilizing all of it.

Is the Memory Wasted?
Yes, the extra memory you've allocated but don't use is technically wasted because it remains reserved but unused. 
The program will still run fine, but this wasted memory could be problematic in scenarios where memory is limited or in long-running programs where memory needs to be managed efficiently.
